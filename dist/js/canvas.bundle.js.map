{"version":3,"sources":["webpack:///webpack/bootstrap 364f509ec4114b7b8dfc","webpack:///./src/canvas.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA","file":"canvas.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 364f509ec4114b7b8dfc","// Initial Setup\r\nconst canvas = document.querySelector('canvas')\r\nconst c = canvas.getContext('2d')\r\n\r\ncanvas.width = innerWidth\r\ncanvas.height = innerHeight\r\n\r\n// Variables\r\nconst mouse = {\r\n    x: innerWidth / 2,\r\n    y: innerHeight / 2\r\n}\r\n\r\nconst starColors = ['white','lightblue']\r\nconst mountColors = ['#3g4045', '#3f3d51', '#4d6174', '#414b60']\r\n\r\n// Event Listeners\r\naddEventListener('mousemove', event => {\r\n    mouse.x = event.clientX\r\n    mouse.y = event.clientY\r\n})\r\n\r\naddEventListener('resize', () => {\r\n    canvas.width = innerWidth\r\n    canvas.height = innerHeight\r\n\r\n    init()\r\n})\r\n\r\n// Utility Functions\r\nfunction randomIntFromRange(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min)\r\n}\r\n\r\nfunction randomColor(colors) {\r\n    return colors[Math.floor(Math.random() * colors.length)]\r\n}\r\n\r\nfunction distance(x1, y1, x2, y2) {\r\n    const xDist = x2 - x1\r\n    const yDist = y2 - y1\r\n\r\n    return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2))\r\n}\r\n\r\n//gravity\r\nvar gravity = 1;\r\nvar friction = 0.5;\r\nvar frictionEnable;\r\nfunction applyGravity(particle, fictionEnable) {\r\n  if(frictionEnable == true){\r\n    if(particle.y + particle.radius > innerHeight){\r\n      if(innerHeight - particle.radius < particle.y) particle.y = innerHeight - (particle.radius);\r\n      particle.velocity.y = -particle.velocity.y * friction;\r\n      particle.velocity.x = particle.velocity.x * friction;\r\n    } else {\r\n      return particle.velocity.y += gravity;\r\n    }\r\n  }\r\n  else {\r\n    if(particle.y + particle.radius > innerHeight){\r\n      particle.velocity.y = -particle.velocity.y;\r\n    } else {\r\n      return particle.velocity.y += gravity;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Rotates coordinate system for velocities\r\n *\r\n * Takes velocities and alters them as if the coordinate system they're on was rotated\r\n *\r\n * @param  Object | velocity | The velocity of an individual particle\r\n * @param  Float  | angle    | The angle of collision between two objects in radians\r\n * @return Object | The altered x and y velocities after the coordinate system has been rotated\r\n */\r\n\r\nfunction rotate(velocity, angle) {\r\n    const rotatedVelocities = {\r\n        x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),\r\n        y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)\r\n    };\r\n\r\n    return rotatedVelocities;\r\n}\r\n\r\n/**\r\n * Swaps out two colliding particles' x and y velocities after running through\r\n * an elastic collision reaction equation\r\n *\r\n * @param  Object | particle      | A particle object with x and y coordinates, plus velocity\r\n * @param  Object | otherParticle | A particle object with x and y coordinates, plus velocity\r\n * @return Null | Does not return a value\r\n */\r\n\r\nfunction resolveCollision(particle, otherParticle) {\r\n    const xVelocityDiff = particle.velocity.x - otherParticle.velocity.x;\r\n    const yVelocityDiff = particle.velocity.y - otherParticle.velocity.y;\r\n\r\n    const xDist = otherParticle.x - particle.x;\r\n    const yDist = otherParticle.y - particle.y;\r\n\r\n    // Prevent accidental overlap of particles\r\n    if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {\r\n\r\n        // Grab angle between the two colliding particles\r\n        const angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);\r\n\r\n        // Store mass in var for better readability in collision equation\r\n        const m1 = particle.mass;\r\n        const m2 = otherParticle.mass;\r\n\r\n        // Velocity before equation\r\n        const u1 = rotate(particle.velocity, angle);\r\n        const u2 = rotate(otherParticle.velocity, angle);\r\n\r\n        // Velocity after 1d collision equation\r\n        const v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };\r\n        const v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y };\r\n\r\n        // Final velocity after rotating axis back to original location\r\n        const vFinal1 = rotate(v1, -angle);\r\n        const vFinal2 = rotate(v2, -angle);\r\n\r\n        // Swap particle velocities for realistic bounce effect\r\n        particle.velocity.x = vFinal1.x;\r\n        particle.velocity.y = vFinal1.y;\r\n\r\n        otherParticle.velocity.x = vFinal2.x;\r\n        otherParticle.velocity.y = vFinal2.y;\r\n    }\r\n}\r\n\r\n// Objects\r\nfunction Star(x,y,radius, color) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.radius = radius;\r\n  this.origRadius = radius;\r\n  this.color = color;\r\n  this.opacity = Math.random();\r\n  this.change = .01;\r\n\r\n\r\n  this.update = function(){\r\n    this.draw();\r\n  }\r\n\r\n  this.draw = () => {\r\n      c.beginPath();\r\n      c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);\r\n      c.save();\r\n      c.globalAlpha = this.opacity;\r\n      c.fillStyle = this.color;\r\n      c.fill();\r\n      c.restore();\r\n      c.closePath();\r\n  }\r\n}\r\n\r\nfunction Piece(x,y,radius,color, parentVelocity) {\r\n  this.x = x;\r\n  this.y = y;\r\n  this.velocity = {\r\n    x: (Math.random() - 0.5) * 10,\r\n    y: (Math.random() + 0.5) * parentVelocity.y\r\n  }\r\n  this.opacity = 1;\r\n  this.radius = radius;\r\n  this.color = color;\r\n  this.mass = 1;\r\n\r\n  this.update = function (){\r\n\r\n    this.opacity = this.opacity * .96;\r\n\r\n    this.x += this.velocity.x;\r\n    this.y += this.velocity.y;\r\n\r\n\r\n    this.draw();\r\n  }\r\n\r\n  this.draw = function() {\r\n    c.beginPath();\r\n    c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);\r\n    c.save();\r\n    c.globalAlpha = this.opacity;\r\n    c.fillStyle = this.color;\r\n    c.fill();\r\n    c.restore();\r\n    c.closePath();\r\n  }\r\n}\r\n\r\nfunction Particle(x, y, radius, color) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.velocity = {\r\n      x: (Math.random() - 0.5) * 20,\r\n      y: (Math.random() + 0.5) * 3\r\n    }\r\n    this.radius = radius;\r\n    this.color = color;\r\n    this.mass = 1;\r\n\r\n    let pieces;\r\n\r\n    this.update = particles => {\r\n\r\n        //other particle collisions\r\n        for(let i = 0; i < particles.length; i++){\r\n          if (this === particles[i]) continue;\r\n          if (distance(this.x, this.y, particles[i].x, particles[i].y) - this.radius * 2 < 0){\r\n            // resolveCollision(this, particles[i]);\r\n          }\r\n        }\r\n\r\n        //wall collisions\r\n        if(this.x - this.radius <= 0 || this.x + this.radius >= innerWidth) this.velocity.x = -this.velocity.x;\r\n\r\n        //Ground Collision\r\n        if(this.y + this.radius >= innerHeight){\r\n          this.radius -= this.radius/2;\r\n          if(pieces == undefined) pieces = [];\r\n          if(pieces != undefined) this.spawnPieces();\r\n          if(this.radius <= 1) this.reset();\r\n        }\r\n\r\n        //particle movement\r\n        this.x += this.velocity.x;\r\n        this.y += this.velocity.y;\r\n\r\n        this.draw();\r\n    }\r\n    this.reset = function() {\r\n      this.x = randomIntFromRange(radius, canvas.width - radius);\r\n      this.y = -radius;\r\n      this.radius = radius * (Math.random() + .2);\r\n      this.velocity.x = (Math.random() - 0.5) * 40;\r\n      this.velocity.y = (Math.random() + 0.5) * 5;\r\n      pieces = [];\r\n    }\r\n\r\n    this.draw = () => {\r\n        c.beginPath();\r\n        c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);\r\n        c.fillStyle = this.color;\r\n        c.fill();\r\n        c.strokeStyle = this.color;\r\n        c.stroke();\r\n        c.closePath();\r\n\r\n        if(pieces != undefined) {\r\n          //Draw all falling stars\r\n          pieces.forEach(piece => {\r\n            applyGravity(piece, frictionEnable);\r\n            piece.update(pieces);\r\n          });\r\n        }\r\n    }\r\n\r\n    this.spawnPieces = function(){\r\n      // pieces = [];\r\n      for(let i = 0; i < 6; i++){\r\n          pieces.push(new Piece(this.x, this.y, 1, 'white', this.velocity));\r\n      }\r\n    }\r\n}\r\n\r\n//Mountain\r\nfunction Mountain(base, height, xOffset, color){\r\n    this.base = base;\r\n    this.height = height;\r\n    this.xOffset = xOffset;\r\n    this.color = color;\r\n\r\n    this.draw = () => {\r\n      c.beginPath();\r\n      c.fillStyle = this.color;\r\n      c.moveTo(this.xOffset + this.base/2,innerHeight - this.height);\r\n      c.lineTo(this.xOffset + this.base, innerHeight);\r\n      c.lineTo(this.xOffset, innerHeight);\r\n      c.lineTo(this.xOffset + this.base/2,innerHeight - this.height);\r\n      c.fill();\r\n\r\n    }\r\n}\r\n\r\n// Implementation\r\n\r\nlet particles;\r\nlet mountains;\r\nlet stars;\r\n\r\nfunction init() {\r\n      particles = [];\r\n      mountains = [];\r\n      stars = [];\r\n\r\n        var base = canvas.width/2;\r\n        var height = base - base * 4/7;\r\n        var xOffset = innerWidth/2 - base/2;\r\n        // ['#494f66', '#3c404f', '#272930', '#242535', '#202133']\r\n        var color = randomColor(mountColors);\r\n        mountains.push(new Mountain(base * 1.5, height * 1.5, xOffset - base/6*1.5, '#3c404f'));\r\n        mountains.push(new Mountain(base, height, xOffset - base/2, '#272930'));\r\n        mountains.push(new Mountain(base, height, xOffset + base/2, '#272930'));\r\n\r\n\r\n      for (let i = 0; i <= 350; i++){\r\n        const radius = randomIntFromRange(1,2);\r\n        let x = randomIntFromRange(radius, canvas.width - radius);\r\n        let y = randomIntFromRange(radius, canvas.height - radius);\r\n        const color = randomColor(starColors);\r\n\r\n        if(i !== 0) {\r\n          for(let j = 0; j < stars.length; j++){\r\n            if(distance(x, y, stars[j].x, stars[j].y) - radius * 2 < 0) {\r\n              x = randomIntFromRange(radius, canvas.width - radius);\r\n              y = randomIntFromRange(radius, canvas.height - radius);\r\n\r\n              j = -1;\r\n            }\r\n          }\r\n        }\r\n        stars.push(new Star(x, y, radius, color));\r\n      }\r\n\r\n      for (let i = 0; i <= 0; i++){\r\n        const radius = 15;\r\n        let x = randomIntFromRange(radius, canvas.width - radius);\r\n        let y = randomIntFromRange(radius, -(canvas.height - radius));\r\n\r\n        if(i !== 0) {\r\n          for(let j = 0; j < particles.length; j++){\r\n            if(distance(x, y, particles[j].x, particles[j].y) - radius * 2 < 0) {\r\n              x = randomIntFromRange(radius, canvas.width - radius);\r\n              y = randomIntFromRange(radius, canvas.height - radius);\r\n\r\n              j = -1;\r\n            }\r\n          }\r\n        }\r\n\r\n        particles.push(new Particle(x, y, radius, 'white'));\r\n      }\r\n}\r\n\r\n// Animation Loop\r\nfunction animate() {\r\n    requestAnimationFrame(animate)\r\n    c.clearRect(0, 0, canvas.width, canvas.height)\r\n\r\n    //Draw all stars\r\n    stars.forEach(star => {\r\n      star.update();\r\n    })\r\n\r\n    //Draw all mountains\r\n    mountains.forEach(mountain => {\r\n      mountain.draw();\r\n    })\r\n\r\n    //friction enable/disable\r\n    // frictionEnable = false;\r\n    frictionEnable = true;\r\n\r\n    //Draw all falling stars\r\n    particles.forEach(particle => {\r\n      applyGravity(particle, frictionEnable);\r\n      particle.update(particles);\r\n    });\r\n\r\n\r\n}\r\n\r\ninit();\r\nanimate();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/canvas.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}